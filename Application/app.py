import os
import csv
import pefile
import tensorflow as tf
import numpy as np
import pandas as pd
import streamlit as st
from math import sqrt, ceil
import cv2
import os
import random
import time
import concurrent.futures
import base64
from streamlit_extras.stylable_container import stylable_container
from pathlib import Path
import hashlib
import requests
import streamlit.components.v1 as html
from tensorflow.keras.models import load_model
# Add Multipage PDF files

# Malware type dictionary
malware_type = {'0':['Backdoor','Mã độc xâm nhập ẩn, kiểm soát và truy cập máy tính từ xa.'], '1':['Downloader','Thực hiện tải các loại mã độc.'], '2':['Keylogger','Ghi lại những phím được nhấn để đánh cắp thông tin người dùng.'], '3':['Miner','Mã độc khai thác tiền điện tử (cryptocurrency) trái phép trên máy tính của người khác.'], '4':['Ransomware','Mã độc mã hóa tệp và yêu cầu tiền chuộc để giải mã chúng.'], '5':['Rogue Software','Phần mềm giả mạo, thường là malware, đánh lừa người dùng để tải về và cài đặt.'], '6':['Trojan','Mã độc giả danh phần mềm hữu ích nhưng thực chất có mục đích độc hại, thường sử dụng để xâm nhập và kiểm soát từ xa hệ thống.'], '7':['Worm','Mã độc tự sao chép và lan truyền trong mạng máy tính mà không cần sự tương tác của người dùng.']}
malware_variant = {'0': 'Adialer.C', '1': 'Agent.FYI', '2': 'Allaple.A', '3': 'Allaple.L', '4': 'Alueron.gen!J', '5': 'Autorun.K', '6': 'C2LOP.P', '7': 'C2LOP.gen!g', '8': 'Dialplatform.B', '9': 'Dontovo.A', '10': 'Fakerean', '11': 'Instantaccess', '12': 'Lolyda.AA1', '13': 'Lolyda.AA2', '14': 'Lolyda.AA3', '15': 'Lolyda.AT', '16': 'Malex.gen!J', '17': 'Obfuscator.AD', '18': 'Rbot!gen', '19': 'Skintrim.N', '20': 'Swizzor.gen!E', '21': 'Swizzor.gen!I', '22': 'VB.AT', '23': 'Wintrim.BX', '24': 'Yuner.A'}

st.set_page_config(layout="wide")
@st.cache_data
def show_pdf(file_path):
    with open(file_path,"rb") as f:
        base64_pdf = base64.b64encode(f.read()).decode('utf-8')
    pdf_display = f'<iframe src="data:application/pdf;base64,{base64_pdf}" width="550" height="800" type="application/pdf"></iframe>'
    st.markdown(pdf_display, unsafe_allow_html=True)
def get_img_as_base64(file):
    with open(file, 'rb') as f:
        img = f.read()
    img = base64.b64encode(img).decode()
    # Default wide mode
    page_bg_img = f"""
    <style>
    [data-testid="stAppViewContainer"] {{
    background-image: url("data:image/jpg;base64,{img}");
    background-size: cover;
    }}
    </style>
    """
    st.markdown(page_bg_img, unsafe_allow_html=True)
    st.write(" ")
    st.write(" ")
    st.write(" ")
    st.write(" ")
    st.markdown("<h1 style='color: darkblue;text-align:center;'>PHẦN MỀM PHÁT HIỆN VÀ PHÂN LOẠI MÃ ĐỘC SỬ DỤNG HỌC MÁY</h1>", unsafe_allow_html=True)
def img_to_bytes(img_path):
    img_bytes = Path(img_path).read_bytes()
    encoded = base64.b64encode(img_bytes).decode()
    return encoded
def img_to_html(img_path, width):
    # Make it center and smaller
    img_html = f"""<div style="display: flex; justify-content: center; align-items: center;">
    <img src='data:image/png;base64,{img_to_bytes(img_path)}' class='img-fluid' style='border: 3mm solid transparent;' width={width}>
    """
    return img_html
def style_df(df):
    # Create a copy of the DataFrame
    styled_df = df.copy()
    # Apply CSS styles and text-align property to all cells in a DataFrame
    styled_df = styled_df.style.set_properties(**{
        # make it in the center of the cell
        'text-align': 'center',
        # set the font size
        'font-size': '15pt',
        # set the font-family
        'font-family': 'Calibri',
        # set the background color
        'background-color':'rgba(255, 255, 255, 0.9)',
        'color': 'black',
    })
    return styled_df
def check_imports(file_upload):
    if file_upload is not None:
        current_directory = os.getcwd()
        # You may need to adjust the path to where the file should be stored
        upload_path = os.path.join(current_directory, "Checking_File", file_upload.name)
        with open(upload_path, 'wb') as f:
            f.write(file_upload.read())
        imported_functions = []
        try:
            # Open the PE file
            pe = pefile.PE(upload_path)
            # Iterate through the imported libraries and their functions
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                for function in entry.imports:
                    if function.name:
                        function_name = function.name.decode("utf-8")
                        if function_name != "None" and "?" not in function_name:
                            imported_functions.append(function_name)
        except Exception as e:
            st.write(f"An error occurred while processing '{file_upload.name}': {str(e)}")
        # Load header from Import.csv
        # cd .. to get to the parent directory
        current_directory = os.path.dirname(current_directory)
        csv_path = os.path.join(current_directory, "Import.csv")
        with open(csv_path, "r") as f:
            csv_reader = csv.reader(f)
            header = next(csv_reader)
        st.markdown("<h1 style='color: black; text-align:center;'>Phân tích dựa trên PE Imports</h1>", unsafe_allow_html=True)

        col1, col2 = st.columns(2)
        with col1:
            df = pd.DataFrame(imported_functions)
            with stylable_container(
                key="import_functions",
                css_styles=[
                    """
                {
                    background-color: white;
                    padding: 0.5em;
                    border: 5px solid black;
                }
                """,
                    """
                .stMarkdown {
                    padding-right: 1.5em;
                }
                """,
                ],
            ):
                st.markdown("""
                <style>
                h2 {
                    background-color: white;
                    padding: 0.1em;
                    text-align: center;
                    border: 3px solid black;
                }
                </style>
                <h2 style='color: black;text-align:center;'>Tập PE Imports</h2>
                """, unsafe_allow_html=True)
                # Table in the center of the page
                st.dataframe(style_df(df), width=656, height=350)
            list_import = []
            # Compare imported functions with header
            for i in header[:-1]:
                if i in imported_functions:
                    list_import.append(1)
                else:
                    list_import.append(0)
        with col2:
            df = pd.DataFrame(list_import)
            with stylable_container(
                key="malware_type",
                css_styles=[
                    """
                {
                    background-color: lightgray;
                    padding: 0.5em;
                    border: 5px solid black;
                }
                """,
                    """
                .stMarkdown {
                    padding-right: 1.5em;
                }
                """,
                ],
            ):
                st.markdown("<h2 style='color: black;text-align:center;'>Loại mã độc</h2>", unsafe_allow_html=True)
                st.markdown(f"<h4 style='color: black; text-align:'>&#x2022; Phân loại mã độc: {malware_type[f'{learn_check_imports(list_import)[0]}'][0]}</h4>", unsafe_allow_html=True)
                st.markdown(f"<h4 style='color: black; text-align:'>&#x2022; Xác suất: {learn_check_imports(list_import)[1]}%</h4>", unsafe_allow_html=True)
                st.markdown(f"<h4 style='color: black; text-align:'>&#x2022; Mô tả: {malware_type[f'{learn_check_imports(list_import)[0]}'][1]}</h4>", unsafe_allow_html=True)
                st.markdown(img_to_html(f"image_file/Type/{malware_type[f'{learn_check_imports(list_import)[0]}'][0]}.png",150), unsafe_allow_html=True)
    return list_import

def learn_check_imports(file_need_check):
    current_directory = os.getcwd()
    # cd .. 
    current_directory = os.path.dirname(current_directory)
    print(current_directory)
    # Load the model
    model = tf.keras.models.load_model(f"{current_directory}/Train/model.h5")
    # Example input data (modify this to match your actual input)
    input_data = np.array([file_need_check])
    # Make predictions
    predictions = model.predict(input_data)
    print(predictions)
    # Đầu tiên, sử dụng hàm argmax để xác định lớp có xác suất cao nhất
    predicted_class = np.argmax(predictions) 
    # Print percentage confidence take ,2 is 2 number after comma
    confident = predictions[0][predicted_class]*100
    confident = round(confident, 2)
    return [predicted_class, confident]
def exfile_image(input_file_name):
    #Read the whole file to data
    with open(input_file_name, 'rb') as binary_file:        
        data = binary_file.read()
    # Data length in bytes
    data_len = len(data)
    # d is a verctor of data_len bytes
    d = np.frombuffer(data, dtype=np.uint8)
    # Assume image shape should be close to square
    sqrt_len = int(ceil(sqrt(data_len)))  # Compute square toot and round up
    # Requiered length in bytes.
    new_len = sqrt_len*sqrt_len
    # Number of bytes to pad (need to add zeros to the end of d)
    pad_len = new_len - data_len
    # Pad d with zeros at the end.
    padded_d = np.hstack((d, np.zeros(pad_len, np.uint8)))
    # Reshape 1D array into 2D array with sqrt_len pad_len x sqrt_len (im is going to be a Grayscale image).
    im = np.reshape(padded_d, (sqrt_len, sqrt_len))
    # Save image
    cv2.imwrite('im.png', im)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    # Resize image to 256x256
    im = cv2.resize(im, (64, 64))
    return im

def output_image(image, file_name):
    random_images = [os.path.join("image_file/Variants", i) for i in os.listdir("image_file/Variants")]
    file_image = exfile_image(file_name)
    st.markdown("<h1 style='color: black; text-align:center;'>Kiểm tra biến thể</h1>", unsafe_allow_html=True)
    col1, col2 = st.columns(2)
    image_left = image
    predicted_category = None
    def predict_image_category(im):
        current_path = os.getcwd()
        current_path = os.path.dirname(current_path)
        model = load_model(current_path + '/Train/malware.h5')
        im = cv2.resize(im, (64, 64))
        # Load and preprocess the image
        img = np.array(im)
        img_rgb = np.dstack((img, img, img))  # Create a 3-channel image with the same grayscale values on each channel
        img_rgb = np.expand_dims(img_rgb, axis=0)  # Add a batch dimensio
        # Make a prediction and print the result
        prediction = model.predict(img_rgb)
        prediction = np.argmax(prediction)
        return prediction
    # Header
    # Tải ảnh đầu vào bên trái
    with col1:
        # Predict image
        predicted_category = predict_image_category(file_image)
        # Display picture but smaller
        if image_left:
            # Hiển thị ảnh bên trái
            with stylable_container(
                key="first_image",
                css_styles=[
                    """
                {
                    background-color: aliceblue;
                    padding: 0.5em;
                    border: 5px solid black;
                }
                """,
                    """
                .stMarkdown {
                    padding-right: 1.5em;
                }
                """,
                ],
            ):
                st.markdown("""
                <style>
                h2 {
                    background-color: white;
                    padding: 0.1em;
                    text-align: center;
                    border: 3px solid black;
                }
                </style>
                <h2 style='color: black;text-align:center;'>Ảnh Xám</h2>""", unsafe_allow_html=True)
                st.markdown(img_to_html(image_left,500), unsafe_allow_html=True)
                file_name = file_name.replace("Checking_File/","")
                st.markdown(f"<h3 style='color: black; text-align: center'>{file_name}</h3>", unsafe_allow_html=True)
                # st.image(image_left, use_column_width=False, width=550)
            # Hiển thị dự đoán nhóm
            st.write("\n \n \n")
            # Kiểm tra nếu predicted_category thuộc nhóm bạn muốn dừng lại
    # Hiển thị ảnh ngẫu nhiên bên phải
    with col2:
        with stylable_container(
        key="variants",
        css_styles=[
            """
        {
            background-color: antiquewhite;
            padding: 0.5em;
            border: 5px solid black;
        }
        """,
            """
        .stMarkdown {
            padding-right: 1.5em;
        }
        """,
        ],
        ):
            st.markdown("""
            <style>
            h2 {
                background-color: white;
                padding: 0.1em;
                text-align: center;
                border: 3px solid black;
            }
            </style>
            <h2 style='color: black;text-align:center;'>Biến thể</h2>""", unsafe_allow_html=True)
            random_image_placeholder = st.empty()
            caption_placeholder = st.empty()
            stop_flag = False  # Biến cờ dừng quá trình lặp
            a = 0
            while not stop_flag:
                random_image_url = random.choice(random_images)
                # Take name of image
                name_image = random_image_url.split("/")[-1]
                # random_image_placeholder.image(random_image_url, use_column_width=False, width=550)
                random_image_placeholder.markdown(img_to_html(random_image_url,500), unsafe_allow_html=True)
                caption = f"<h3 style='color: black; text-align: center'>{name_image}</h3>"
                caption_placeholder.markdown(caption, unsafe_allow_html=True)
                time.sleep(0.25)  # Thời gian chờ giữa các ảnh (1 giây trong ví dụ này)
                a+=1
                # clean the cache
                if a > 25:
                    # in ảnh có tên predict_category ở trong random_images and caption is bold
                    random_image_placeholder.markdown(img_to_html(f"image_file/Variants/{malware_variant[f'{predicted_category}']}.png",500), unsafe_allow_html=True)
                    stop_flag = True
def call_api_virustotal(file_path):
    # Calculate the MD5 hash of the file
    with open(file_path, "rb") as file:
        file_contents = file.read()
        md5_hash = hashlib.md5(file_contents).hexdigest()
    
    # Define the VirusTotal API URL
    api_url = "https://www.virustotal.com/vtapi/v2/file/report"
    
    # Set the API key as a parameter in the request
    params = {
        'apikey': '0822dbdeafbc2038c1004beb440fd2fb8991247bdaa233dc5c3e5ccb37cbd298',
        'resource': md5_hash
    }
    # Make the HTTP request to VirusTotal
    response = requests.get(api_url, params=params)
    # Call streamlit column
    with stylable_container(
    key="virustotal",
    css_styles=[
        """
    {
        background-color: black;
    }
    """,
        """
    .stMarkdown {
        padding-right: 1.5em;
    }
    """,
    ],
    ):
    # Check the response status code
        if response.status_code == 200:
            result = response.json()
            if result["response_code"] == 1:
                # File is in the database, you can access scan reports and more in the 'result' dictionary
                print("VirusTotal Scan Report:")
                # Add image virus total
                st.markdown(img_to_html("image_file/Virustotal/virustotal.png",500), unsafe_allow_html=True)
                # make json into table
                

                st.json(result, expanded=False)
            else:
                with stylable_container(
                key="virustotal",
                css_styles=[
                    """
                {
                    background-color: black;
                }
                """,
                    """
                .stMarkdown {
                    padding-right: 1.5em;
                }
                """,
                ],
                ):
                    st.markdown(img_to_html("image_file/Virustotal/virustotal.png",500), unsafe_allow_html=True)
                    st.markdown("<h3 style='color: white; text-align: center'>File không có trong cơ sở dữ liệu của VirusTotal</h3>", unsafe_allow_html=True)

        else:
            print("Error making the request to VirusTotal. Status code:", response.status_code)
        with stylable_container(
        key="virustotal",
        css_styles=[
            """
        {
            background-color: black;
        }
        """]):
            st.markdown("""""")
def main():
    #Background
    get_img_as_base64('image_file/BackGround/background.jpg')
    # drag a file to Checking_File
    file_upload = st.file_uploader("Upload Files", type=["exe","vir"])
    # Then call function check_imports
    if file_upload is not None:
        check_imports(file_upload)
        # Call function to display image
        output_image("im.png", f'Checking_File/{file_upload.name}')
        # Check variant of malware
        # Call API VirusTotal
        call_api_virustotal(f'Checking_File/{file_upload.name}')
    # Streamlit to display pdf      
if __name__ == "__main__":
    main()